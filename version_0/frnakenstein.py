#! /usr/bin/env python

from sys import stdout
from individual import Individual, BaseDistribution, Objective, BoltzmannObjective, RelativeBoltzmannObjective, Fitness, BoltzmannFitness, LogBoltzmannFitness, ThresholdBoltzmannFitness, RelativeBoltzmannFitness, CombinedFitness, RandomPosition, WrongPosition, BoltzmannPosition, MinBoltzmannPosition, LogBoltzmannPosition, RelativeBoltzmannPosition, CombinedPosition, RandomCut, CorrectCut, BoltzmannCut, MinBoltzmannCut, RelativeBoltzmannCut, CombinedCut, MutateDependent, WeightedMutateDependent
from population import Population, Mutate, RandomMutate, FitnessWeightedMutate, SelectPair, WeightedSelectPair, SelectCut, WeightedSelectCut, CombinedSelectPair, Reduce, DiversityReduce, Recombine
from structure import Structure, Target, int2str, combinestructures

# Function outputting the members of population sorted by objective
def output_population(pop, file = stdout, format = None):
  if format == None:
    def format(seq, obj, fit, struc, id):
      f = "Sequence: {0}\n Objective: {1}, Fitness: {2}\n Structure{3}".format(seq, obj, fit, int(len(struc) > 1) * "s")
      for s in struc:
        if s[0] != None:
          f += "\n  {0}, T = {1}".format(s[0], s[1])
        else:
          f += "\n  {0}".format(s[0])
      if id != None:
        f += "\n ID: {0}".format(id)
      return f
  target = pop.gettarget()
  temps = set([])
  for t in target:
    temps.add(t.temperature)
  def getstructures(ind):
    tseq = []
    for t in temps:
      tseq.append((ind.getstruc(t).bracket(), t))
    return tseq

  m = [(i.getobjective(), i.getfitness(), i.getseq(), getstructures(i), i.getid()) for i in pop.members]
  m.sort()
  for i in m:
    print >> file, format(i[2], i[0], i[1], i[3], i[4])

# Function running a GA to construct sequences folding into target,
# which should be a Target object. Population size is fixed at npop,
# in each generation nmut mutants are created and nxov crossovers are
# performed. Population and Individual are classes for representing
# the population and an individual.
def ga(target, npop, ngen, nmut, nxov, Population, Individual, logfile = None, basedist = None, stoppingcriteria = None, nrandom = None, report = None, track = False, precompute = None):
  # Set up distribution for drawing nucleotides
  if basedist != None and not isinstance(basedist, BaseDistribution):
    w = []
    for name in ["unpaired", "basepair", "paired"]:
      if name in basedist:
        w.append(basedist[name])
      elif hasattr(name, basedist):
        w.append(getattr(name, basedist))
      else:
        w.append(None)
    basedist = BaseDistribution(*w)
  # Set up initial population of npop random individuals
  pop = Population(target, Individual, basedist)
  if track:
    pop.addrandom(npop, idfunc = (lambda x: str(x)))
  else:
    pop.addrandom(npop)
  if precompute != None:
    precompute(pop.new)
  pop.addnew()
  # Evolve population for ngen generations
  for g in xrange(ngen):
    # Create nmut mutated sequences
    pop.mutate(nmut)
    # Create nxov sequences generated by crossover
    pop.recombine(nxov)
    # Add newly created sequences to population
    tmp = list(pop.new)
    pop.addnew()
    # Random sequences should not be considered for elimination until
    # next round, but need to be part of the precomputation
    if nrandom != None and g != ngen - 1:
      # Add random sequences to maintain diversity
      if track:
        pop.addrandom(nrandom, idfunc = (lambda x: str(g) + "." + str(x)))
      else:
        pop.addrandom(nrandom)
    # Precompute structural information (can be used to parallellise
    # computations or prevent initial computation of MFE structure
    # followed by Boltzmann computation that also computes MFE
    # structure).
    if precompute != None:
      precompute(tmp + list(pop.new))
    # Reduce population to fixed size
    pop.reduce(npop)

    if logfile != None:
      # Output current status to log file
      print >> logfile, "=== Population after generation {0} ===".format(g)
      output_population(pop, logfile)

    if report != None:
      report(pop, g)

    if stoppingcriteria != None and stoppingcriteria(pop):
      # Stop genetic algorithm
      if logfile != None:
        print >> logfile, "Stopping criteria met after generation", g
        break

    # Promote random sequences to full members
    pop.addnew()

  return pop

if __name__ == "__main__":
  # Set up command line interface for running GA
  from argparse import ArgumentParser, ArgumentError, FileType, Action
  from sys import argv, stdout
  from types import StringType
  from individual import RandomPosition, WrongPosition, BoltzmannPosition
  parser = ArgumentParser(argv[0] + " [options]\nRuns a genetic algorithm attempting to create sequences folding into the specified targets")
  class TargetAction(Action):
    def __call__(self, parser, namespace, values, option_string = None):
      if len(values) < 1:
        raise ArgumentError, "Missing argument for target specification"
      if len(values) > 2:
        raise ArgumentError, "Too many arguments in target specification"

      # Function for transforming to a canonical dot-bracket notation
      def transform(s):
        t = ""
        for i in s:
          if i in "[{(<":
            t += '('
          elif i in "]})>":
            t += ')'
          elif i in ".-_:":
            t += '.'
          elif not i.isspace():
            raise ArgumentError, "Unexpected character " + i + "in target specification"
        return t

      if len(values) == 2:
        # Determine temperature
        try:
          T = int(values[1])
        except ValueError:
          try:
            T = float(values[1])
          except ValueError:
            raise ArgumentError, "Temperature in target specification should be a real or integer value"
      else:
        T = None
      struc = Structure(transform(values[0]), T)
      try:
        struc.validate()
      except ValueError:
        raise ValueError, "Structure " + values[0] + " not well formed"
      try:
        if namespace.target.size() != len(struc):
          raise ValueError, "Structure " + values[0] + " not of the same length as previous target structure(s)"
      except AttributeError:
        namespace.target = Target()
      namespace.target.addstructure(struc)
  parser.add_argument("-t", action = TargetAction, required = True, nargs = "*", help = "Add structure S as target structure. If a temperature T is specified, the target is assumed to be for this temperature, otherwise folding at default temperature is performed.", metavar = "S T")
  parser.add_argument("-g", default = 50, type = int, help = "Run Genetic Algorithm for G generations")
  parser.add_argument("-s", default = 50, type = int, help = "Set population size to N", metavar = "N")
  parser.add_argument("-m", default = 50, type = int, help = "Create N mutants in each generation", metavar = "N")
  parser.add_argument("-x", default = 50, type = int, help = "Create N recombinants in each generation", metavar = "N")
  parser.add_argument("-i", default = False, action = "store_true", help = "Assign unique identifier to all founder sequences, keep track of which founders have contributed to each individual, and output this information with the individuals")
  parser.add_argument("-v", default = 0, const = 2, type = int, nargs = '?', help = "Set verbosity to level N", metavar = "N")
  parser.add_argument("-l", default = None, type = FileType('w'), help = "Write log information to file F", metavar = "F")
  parser.add_argument("-b", default = False, action = "store_true", help = "Break of search when a perfect solution (as defined by the objective) has been found")
  parser.add_argument("--unpaired", nargs = 4, type = float, default = None, help = "Set distribution from which to draw bases in unpaired positions to p1,...,p4", metavar = "p")
  parser.add_argument("--basepair", nargs = 6, type = float, default = None, help = "Set distribution from which to draw base pairs to p1,...,p6", metavar = "p")
  parser.add_argument("--paired", nargs = 4, type = float, default = None, help = "Set distribution from which to draw bases in paired positions to p1,...,p4", metavar = "p")
  parser.add_argument("--mutateall", dest = "mutate", default = Mutate, const = Mutate, action = "store_const", help = "Create equally many mutants from each sequence in current population")
  parser.add_argument("--mutaterandom", dest = "mutate", const = RandomMutate, action = "store_const", help = "Choose sequences for mutation uniformly at random with replacement")
  parser.add_argument("--mutatefit", dest = "mutate", const = FitnessWeightedMutate, action = "store_const", help = "Choose sequences for mutation at random based on fitness")
  parser.add_argument("--randomposition", dest = "position", default = RandomPosition, const = RandomPosition, action = "store_const", help = "Use uniformly random selection of position to mutate")
  parser.add_argument("--wrongposition", dest = "position", const = WrongPosition, action = "store_const", help = "Choose a random position with wrong predicted structure to mutate")
  parser.add_argument("--boltzmannposition", dest = "position", const = BoltzmannPosition, action = "store_const", help = "Choose position to mutate based on the Boltzmann probability that it has an incorrect structure")
  parser.add_argument("--minboltzmannposition", dest = "position", const = MinBoltzmannPosition, action = "store_const", help = "Choose position to mutate based on maximum Boltzmann probability over all targets that it has an incorrect structure")
  parser.add_argument("--logboltzmannposition", dest = "position", const = LogBoltzmannPosition, action = "store_const", help = "Choose position to mutate based on negative logarithm of it having correct structure")
  def CombinedAction(attr, cls):
    class _CombinedAction(Action):
      __combinedactionattr = attr
      __combinedactionclass = (lambda s, x, y, z: cls(x, y, z))
      def __call__(self, parser, namespace, values, option_string = None):
        if len(values) == 0:
          namespace.__setattr__(self.__combinedactionattr, self.__combinedactionclass())
        elif len(values) == 3:
          def _parseweight(w):
            try:
              w = int(w)
            except ValueError:
              try:
                w = float(w)
              except ValueError:
                pass
            if type(w) == StringType or w < 0:
                raise ValueError, "Weight " + w + " for combining schemes is invalid"
            return w
          namespace.__setattr__(self.__combinedactionattr, self.__combinedactionclass(*map(_parseweight, values)))
        else:
          raise ValueError, "Combined scheme takes 0 or exactly 3 arguments, got {0}".format(len(values))
    return _CombinedAction
  parser.add_argument("--combinedposition", nargs = "*", action = CombinedAction("position", CombinedPosition), help = "Choose position to mutate by combining --wrongposition, --boltzmannposition, and --relativeposition, i.e. based on a weighted sum of errors in predicted structure, Boltzmann probability of error, and difference between Boltzmann probability of correct structure and maximum probability of incorrect structure; if no weights are specified, each is given equal weight", metavar = "W W W")
  parser.add_argument("--weightdependent", dest = "wdependent", const = WeightedMutateDependent, default = MutateDependent, action = "store_const", help = "When mutating positions because of dependency on position of original mutation, bias draw by the scores used to choose mutation position (see --mutateX options)")
  parser.add_argument("--randomxover", dest = "xover", const = (RandomCut, SelectCut), action = "store_const", default = (RandomCut, SelectCut), help = "Choose cross over points uniformly at random")
  parser.add_argument("--correctxover", dest = "xover", const = (CorrectCut, WeightedSelectCut), action = "store_const", help = "Choose cross over points according to the fraction of positions with correct structure in the relevant regions of the recombining sequences")
  parser.add_argument("--boltzmannxover", dest = "xover", const = (BoltzmannCut, WeightedSelectCut), action = "store_const", help = "Choose cross over points according to the fraction of expected number of positions with correct structure under the Boltzmann distribution, taken over the relevant regions of the recombining sequences")
  parser.add_argument("--minboltzmannxover", dest = "xover", const = (MinBoltzmannCut, WeightedSelectCut), action = "store_const", help = "Choose cross over points according to sum of minimum probability of having correct structure under the Boltzmann distribution, taken over all targets")
  parser.add_argument("--relativexover", dest = "xover", const = (RelativeBoltzmannCut, WeightedSelectCut), action = "store_const", help = "Choose cross over points according to sum of scores based on difference between Boltzmann probability of correct structure and maximum probability of incorrect structure, taken over the relevant regions of the recombining sequences")
  def combinewithWSC(wrongweight, boltzmannweight, relativeboltzmannweight):
    return (CombinedCut(wrongweight, boltzmannweight, relativeboltzmannweight), WeightedSelectCut)
  parser.add_argument("--combinedxover", nargs = "*", action = CombinedAction("xover", combinewithWSC), help = "Choose cross over points according to a weighted mix of the --correctxover, --boltzmannxover, and --relativexover schemes; if no weights are specified, each scheme contributes equally", metavar = "W W W")
  parser.add_argument("--randompairs", dest = "pairs", const = SelectPair, default = SelectPair, action = "store_const", help = "Select random pairs of individuals for cross overs")
  parser.add_argument("--weightedpairs", dest = "pairs", const = WeightedSelectPair, action = "store_const", help = "Select pairs by independently choosing individuals relative to their fitness")
  parser.add_argument("--combinedpairs", dest = "pairs", const = CombinedSelectPair, action = "store_const", help = "Select pairs based on the average weight of a cross over point squared for the pair") 
  def positiveint(x):
    x = int(x)
    if x <= 0:
      raise ValueError, x + " is a non-positive integer"
    return x
  parser.add_argument("--addrandom", default = None, type = positiveint, help = "Add N random sequences in each generation. Newly added sequences can immediately be used for mutations and recombinations", metavar = "N")
  parser.add_argument("--errorobjective", dest = "objective", const = Objective, default = Objective, action = "store_const", help = "Use number of positions with incorrect predicted structure as objective, with a sequence with predicted structure(s) perfectly matching the target structure(s) considered a perfect solution")
  def boltzmannobjective(x):
    try:
      x = int(x)
      if x < 0 or x > 1:
        raise ValueError
    except ValueError:
      try:
        x = float(x)
        if x < 0 or x > 1:
          raise ValueError
      except ValueError:
        raise ArgumentError, "Precission for a Boltzmann objective function needs to be a number between 0 and 1"
    return BoltzmannObjective(x)
  parser.add_argument("--boltzmannobjective", dest = "objective", nargs = "?", const = BoltzmannObjective(), type = boltzmannobjective, help = "Use expected number of incorrect positions under the Boltzmann distribution as objective. If a precission p is specified, the requirement for a perfect solution is that all structural features (base pairs and unpaired positions) have probability at most p of being wrong, with default behaviour corresponding to p = 0", metavar = "p")
  def relativeboltzmannobjective(x):
    try:
      x = int(x)
    except ValueError:
      try:
        x = float(x)
      except ValueError:
        pass
    if type(x) == StringType or x < -1 or x > 1:
      raise ValueError, "Precission for a relative Boltzmann objective function needs to be a number in the range from -1 to 1"
  parser.add_argument("--relativeobjective", dest = "objective", nargs = "?", const = RelativeBoltzmannObjective(), type = relativeboltzmannobjective, help = "Use score based on difference between Boltzmann probability of correct structure and maximum probability of incorrect structure as objective. If a precission p is specified, the requirement for a perfect solution is that this difference is at least p for all positions, with default behaviour corresponding to p = 0", metavar = "p")
  parser.add_argument("--errorfitness", dest = "fitness", const = Fitness, default = Fitness, action = "store_const", help = "Use fraction of positions with incorrect predicted structure as fitness")
  parser.add_argument("--boltzmannfitness", dest = "fitness", const = BoltzmannFitness, action = "store_const", help = "Use fraction of expected number of positions with incorrect structure under the Boltzmann distribution as fitness")
  parser.add_argument("--logboltzmannfitness", dest = "fitness", const = LogBoltzmannFitness, action = "store_const", help = "Use sum of negative log Boltzmann probabilities of correct structure as fitness")
  def thresholdboltzmannfitness(x):
    try:
      x = int(x)
      if x < 0 or x > 1:
        raise ValueError
    except ValueError:
      try:
        x = float(x)
        if x < 0 or x > 1:
          raise ValueError
      except ValueError:
        raise ArgumentError, "Threshold for Boltzmann fitness function needs to be a number between 0 and 1"
    return ThresholdBoltzmannFitness(x)
  parser.add_argument("--thresholdboltzmannfitness", dest = "fitness", nargs = 1, type = thresholdboltzmannfitness, help = "Use fraction of positions not having probability of the correct structure above threshold T under the Boltzmann distribution as fitness", metavar = "T")
  parser.add_argument("--relativefitness", dest = "fitness", const = RelativeBoltzmannFitness, action = "store_const", help = "Use differences at each position between probability of correct structure and maximum probability of incorrect structure under the Boltzmann distribution as fitness")
  parser.add_argument("--combinedfitness", nargs = "*", action = CombinedAction("fitness", CombinedFitness), help = "Use a weighted mix of --errorfitness, --boltzmannfitness, and --relativefitness as fitness; if no weights are specified, all contribute equally", metavar = "W W W")
  def nonnegativenumber(x):
    try:
      x = int(x)
    except ValueError:
      x = float(x)
    if x < 0:
      raise ValueError, x + " is not a non-negative numer"
    return x
  parser.add_argument("--diversity", default = 0, type = nonnegativenumber, help = "Augment fitness with average fraction of positions identical to sequences already selected when choosing individuals progressing to the next generation")
  options = parser.parse_args()
  # One class to rule them all, and in the darkness bind them
  class Monster(Individual, options.position, options.wdependent, options.xover[0], options.fitness, options.objective):
    pass
  if options.diversity != 0:
    reduceclass = DiversityReduce(options.diversity)
  else:
    reduceclass = Reduce
  # Well, two actually...
  class Frankenstein(Population, Recombine, options.mutate, options.xover[1], options.pairs, reduceclass):
    pass

  basedist = BaseDistribution(options.unpaired, options.basepair, options.paired)
  if options.b:
    # Set up function for determining when a perfect design has been reached
    def perfection(pop):
      for i in pop.members:
        if i.perfectsolution():
          return True
      return False
  else:
    perfection = None

  if "__getboltzmannprediction__" in dir(Monster):
    # Set up function for making sure that we do not fold before
    # computing Boltzmann probabilities (as this would be a waste of
    # time).
    def precompute(individuals):
      temperatures = None
      for i in individuals:
        if temperatures == None:
          temperatures = set([t.temperature for t in i.getpopulation().gettarget()])
        for t in temperatures:
          i.getboltzmann(t)
  else:
    precompute = None

  # Set up function for printing progress
  if options.v <= 0:
    report = None
  elif options.v == 1:
    def report(pop, g):
      stdout.write('#')
  else:
    def report(pop, g):
      print "Finished generation", g + 1
      m = sorted([(i.getfitness(), i) for i in pop.members])[0]
      print "Best fitness is", m[0]
      print int2str(m[1].seq)
      print "Objective:", m[1].getobjective()
      for t in pop.gettarget():
        print combinestructures(m[1].getstruc(t.temperature).bracket(), t.bracket()) + ", T =", t.temperature

  pop = ga(options.target, options.s, options.g, options.m, options.x, Frankenstein, Monster, logfile = options.l, basedist = basedist, stoppingcriteria = perfection, nrandom = options.addrandom, report = report, precompute = precompute, track = options.i)
  output_population(pop)
